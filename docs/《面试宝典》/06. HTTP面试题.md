---
title:  HTTP面试题
date: 2022-09-21 16:23:07
permalink: /pages/143a44/
categories:
  - 《面试宝典》
tags:
  - HTTP
author:
  name: 瑶麦
  link: https://github.com/Bunny0927
---
## 1. [HTTP和HTTPS的区别](https://vue3js.cn/interview/http/HTTP_HTTPS.html)

1. `HTTPS`是`HTTP`协议的安全版本，`HTTP`协议的数据传输是明文的，所以不安全，`HTTPS`使用了`SSL`/`TLS`协议进行了加密处理，相对更安全
2. `HTTP`和`HTTPS`使用连接方式不同，默认端口也不一样，`HTTP`是80，`HTTPS`是443
3. `HTTPS`由于需要设计加密以及多次握手，性能方面不如`HTTP`
4. `HTTPS`需要`SSL`证书，费用较高

## 2. **[HTTPS是如何保证安全的](https://vue3js.cn/interview/http/HTTPS.html)**

`HTTP`在通信过程中，存在以下问题：

- 通信使用明文（不加密），内容可能被窃听
- 不验证通信方的身份，有可能遭遇伪装

`HTTPS`是建立在`SSL`之上，其安全性由`SSL`来保证。`SSL`保证安全主要依赖于三种方法：

> 1. **混合加密**
>

在`HTTPS`通信过程中，采用的是**对称加密+非对称加密**，也就是混合加密的方式。

- **对称加密**：加密和解密使用的秘钥都是同一个，是对称的，对称加密⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。
- **非对称加密**：存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密。公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。⾮对称加密虽然安全性更⾼，但是速度很慢，影响性能。
- **混合加密**：发送密文的一方使用对方的公钥进行加密处理对称的密钥，然后对方用自己的私钥解密拿到对称的密钥，这样可以在确保交换的密钥是安全的前提下，使用对称加密方式进行通信。

![https://cdn.jsdelivr.net/gh/liuzw-cyy/images/img/混合加密.png](https://cdn.jsdelivr.net/gh/liuzw-cyy/images/img/混合加密.png)

> 2.**摘要算法**
>

一种特殊的压缩算法，它能够把任意长度的数据压缩成固定长度且独一无二的字符串，摘要算法保证了数字摘要和原文是完全等价的，只要在原文后附上它的摘要，就能够保证数据的完整性。

> 3.**数字签名**
>

数字签名可以保证消息确实是由发送方签名并发出来的，签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后再比对原文验证完整性，就可以验证消息的安全。CA验证机构可以保证公钥的合法性。

CA验证机构将公钥关联的各种信息打包并签名形成**数字证书**，客户端可使用CA认证机构的公开密钥，对证书上的数字签名进行验证，通过则代表服务器的公开密钥是值得信赖的。

## 3. [TCP和UDP的区别](https://vue3js.cn/interview/http/UDP_TCP.html)

|  | TCP | UDP |
| --- | --- | --- |
| 可靠性 | 可靠 | 不可靠 |
| 连接性 | 面向连接 | 无连接 |
| 报文 | 面向字节流 | 面向报文 |
| 效率 | 传输效率低 | 传输效率高 |
| 双共性 | 全双工 | 一对一、一对多、多对一、多对多 |
| 传输效率 | 慢 | 快 |
1. `TCP`是面向连接的协议，建立连接3次握手、断开连接4次挥手，`UDP`是面向无连接的协议，数据传输前后不连接，发送端只负责将数据发送到网络，接收端从消息队列读取
2. `TCP`提供可靠的服务，可以确保数据无差错，不丢失。`UDP`则尽可能传递数据，但不保证传递交付给对方
3. `TCP`面向字节流，将应用层报文看成一串无结构的字节流，分解为多个`TCP`报文段传输后，在目的站重新装配。`UDP`协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用
4. `TCP`只能点对点全双工通信。`UDP`支持一对一、一对多、多对一和多对多的交互通信
5. `TCP`适用于对效率要求低，对准确性要求高或者要求有链接的场景，传输效率慢，而`UDP`适用场景为对效率要求高，对准确性要求低的场景，传输效率快

> `UDP`协议为什么不可靠？
>

`UDP`在传输数据之前不需要先建立连接，远程主机的传输层在接收到`UDP`报文后，不需要确认，提供不可靠交付。

## 4. [OSI七层模型](https://vue3js.cn/interview/http/OSI.html)

`OSI`将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。

1. **应用层：**通过应用程序间的交互来完成特定的网络应用
2. **表示层**：使通信的应用程序能够解释交换数据的含义，其位于`OSI`参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。
3. **会话层**：负责建立、管理和终止表示层实体之间的通信会话
4. **传输层**：为两台主机进程之间的通信提供服务
5. **网络层**：选择合适的网间路由和交换节点，确保数据按时成功传送
6. **数据链路层**：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 `IP`数据报组装成帧，在两个相邻节点间的链路上传送帧
7. **物理层**：实现计算机节点之间比特流的透明传送

## **5. [TCP/IP协议](https://vue3js.cn/interview/http/TCP_IP.html)**

TCP/IP模型包括应用层、传输层、网络层、数据链路层和物理层。

1. **应用层**：通过不同的应用层协议为不同的应用进程提供服务
2. **传输层**：为上层实体提供源端到对端主机的通信功能
3. **网络层**：为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机
4. **数据链路层**：数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧
5. **物理层**：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境

## 6. [DNS协议](https://www.notion.so/Mikasa-1033f03a16184e62b06d7cb59c518c8a)

`DNS`提供的是一种主机名到`IP`地址的转换服务，被称作域名系统。

> `DNS`服务器解析域名的过程
>
1. 首先会在**浏览器的缓存**中查找对应的`IP`地址，如果查找到直接返回，若找不到继续下一步
2. 将请求发送给**本地`DNS`服务器**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
3. 本地`DNS`服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
4. 本地`DNS`服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
5. 本地`DNS`服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果
6. 本地`DNS`服务器将返回结果保存在缓存中，便于下次使用
7. 本地`DNS`服务器将返回结果返回给浏览器

## 7. [内容分发网络(CDN)是什么](https://vue3js.cn/interview/http/CDN.html)

`CDN`是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率，简单来说就是根据用户位置分配最近的资源。

## 8. **HTTP1.0与1.1、HTTP1.1与2.0 的区别**

> **HTTP1.0**：
>
- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个`TCP`连接

> **HTTP1.1**：
>
- 引入了持久连接，即`TCP`连接默认不关闭，可以被多个请求复用
- 在同一个`TCP`连接里面，客户端可以同时发送多个请求
- 存在**队头堵塞**的现象：`HTTP`规定报文必须是一发一收，这就形成了一个先进先出的串行队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。
- 新增了一些请求方法，如`PUT`、`HEAD`、`OPTIONS`等
- 新增了`host`字段，用来指定服务器的域名。

> **HTTP2.0**：
>
- 采用二进制格式而非文本格式传输数据
- 使用多路复用，只需一个连接即可实现并行，避免`HTTP1.1`中队头堵塞的问题
- 压缩头信息，降低开销
- 服务器推送：允许服务端推送资源给客户端

## 9. 说一下多路复用

`HTTP1.x`是基于文本传输数据的，多路复用基于二进制帧传输消息和数据流。多路复用代替了`HTTP1.x`的序列和阻塞机制，所有的相同域名请求都通过同一个`TCP`连接并发完成，该连接可以同时发送多个请求和承载任意数量的双向数据流，每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。对端可以通过帧中的标识知道属于哪个请求，可以避免`HTTP`旧版本中的队头阻塞问题，极大的提高传输性能。

## 10. **HTTP 3.0是什么**

`HTTP3.0`基于`UDP`协议实现了类似于`TCP`的多路复用数据流、传输可靠性等功能，被称`QUIC`协议。

1. **流量控制、传输可靠性功能**：`QUIC`在`UDP`协议的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些`TCP`中的特性。
2. **多路复用**：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了`TCP`的队头阻塞问题。
3. **快速握手**：由于基于`UDP`协议，可以实现使用0~1个`RTT`来建立连接。

## 11. HTTP常用状态码

- 100：客户端在发送`POST`数据给服务器前，征询服务器情况，看服务器是否处理`POST`的数据，如果不处理，客户端则不上传`POST`数据，如果处理，则`POST`上传数据。常用于`POST`大数据传输
- 206：一般用来做断点续传，或者是视频文件等大文件的加载
- 301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名
- 302：临时重定向不会缓存，常用于未登陆的用户访问用户中心重定向到登录页面
- 304：命中协商缓存，直接使用缓存中的数据
- 400：参数有误，请求无法被服务器识别
- 403：客户端禁止访问该站点或者资源
- 404：服务器找不到资源
- 503：服务器停机维护时，主动用503响应请求或超过`nginx`设置的限速时，会返回503
- 502: 服务器错误
- 504：网关超时

## 12. get请求和post请求的区别

1. **浏览器回退表现不同：**`GET`请求在浏览器回退时是无害的，而`POST`请求会再次提交请求
2. **浏览器对响应的处理不同：**`GET`请求参数会被完整的保留在浏览器历史记录里，而`POST`请求中的参数不会被保留
3. **参数大小不同：**`GET`请求在`URL`中传送的参数是有长度的限制，而`POST`请求没有限制
4. **安全性不同：**`GET`请求参数通过`URL`传递，会暴露出来，不安全；`POST`请求放在`Request Body`中，相对更安全
5. **针对数据操作的类型不同：**`GET`请求对数据进行查询，`POST`请求主要对数据进行修改

## 13. HTTP常见的请求头

> **请求头：**
>
1. `Accept`：浏览器能够处理的内容类型
2. `Accept-Charset`：浏览器能够显示的字符集
3. `Accept-Encoding`：浏览器能够处理的压缩编码
4. `Accept-Language`：浏览器当前设置的语言
5. `Connection`：该浏览器想要优先使用的连接类型
6. `Date`：发送该消息的日期和时间
7. `Cookie`：当前页面cookie的设置
8. `Host`：发出请求的页面所在的域
9. `Referer`：发出请求的页面的`URL`
10. `User-Agent`：浏览器的浏览器身份标识字符串

## 14. **[TCP为什么需要三次握手和四次挥手](https://vue3js.cn/interview/http/handshakes_waves.html)**

> **三次握手**
>

三次握手（`Three-way Handshake`）其实就是指建立一个`TCP`连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。

刚开始客户端处于`Closed`的状态，服务端处于`Listen`状态。进行三次握手：

- **第一次握手**：客户端发送连接请求报文段，将`SYN`位设置为1， `Sequence Number`为x；此时客户端处于`SYN_SEND`状态；
- **第二次握手**：服务器收到客户端的`SYN`报文之后，将`Acknowledgment Number`设置为
`x+1`(`Sequence Number+1`)，自身的`SYN`设置为1，`Sequence Number`为y，一并发送给客户端，此时服务器处于`SYN_RECV`状态；
- **第三次握手**：客户端收到报文之后，将`Acknowledgment Number`设置为`y+1`向服务器发送`ACK`报文。此时客户端处于`ESTABLISHED`状态。服务器收到`ACK`报文之后，也处于 `ESTABLISHED`状态，此时，双方已建立起了连接。

![https://cdn.jsdelivr.net/gh/liuzw-cyy/images/img/三次握手.png](https://cdn.jsdelivr.net/gh/liuzw-cyy/images/img/三次握手.png)

> **为什么不是两次握手?**
>

**每一次握手的作用**：

- 第一次握手：客户端发送网络包，服务端收到了
这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了
这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的，不过此时服务器并不能确认客户端的接收能力是否正常
- 第三次握手：客户端发包，服务端收到了
这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常

假设主机A为客户端，主机B为服务器端。采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。

失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，完成数据传输。

考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。

> **四次挥手**
>

终止一个`TCP`连接，需要经过四次挥手

过程如下：

- 第一次挥手：客户端发送一个`FIN`报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1`状态，停止发送数据，等待服务端的确认。
- 第二次挥手：服务端收到`FIN`报文之后会发送`ACK`报文，且把客户端的序列号值**+1**作为 `ACK`报文的序列号值，表明已经收到客户端的报文了，此时服务端处于`CLOSE_WAIT`状态。
- 第三次挥手：服务端向客户端发送`FIN`报文，请求关闭连接，此时服务端处于 `LAST_ACK` 的状态。
- 第四次挥手：客户端收到`FIN`报文之后，向服务端发送一个`ACK`报文作为应答，此时客户端处于`TIME_WAIT`状态，等待2`MSL`时间后如果没有收到回复则服务端正常关闭（`CLOSED`状态），此时客户端关闭连接，进入`CLOSED`状态。

![https://cdn.jsdelivr.net/gh/liuzw-cyy/images/img/四次挥手.png](https://cdn.jsdelivr.net/gh/liuzw-cyy/images/img/四次挥手.png)

> **为什么需要四次挥手？**
>

服务端在收到客户端断开连接`FIN`报文后，并不会立即关闭连接，而是先发送一个`ACK`包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送`FIN`报文断开连接，因此需要四次挥手。

## 15. 强制缓存和协商缓存的区别

浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档，而不必再像服务器请求数据。

**强制缓存**：根据`Expires`(请求头中的过期时间)判断，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存，**并不会向服务端发起请求**，展示为200状态。

**协商缓存**：如果没有命中强缓存，**客户端向服务端发送**带有`If-None-Match`和`If-Modified-Since`的请求进行协商判断，如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；没有命中则服务器最终会返回资源的实际内容，并更新`header`中的相关缓存字段。

## 16. [WebSocket是什么](https://www.notion.so/HTTP-11e48f195a09447f9227e5f9e4866781)

`WebSocket`是一种网络传输协议，位于`OSI`模型的应用层。可在单个`TCP`连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅，客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。

`WebSocket`的出现解决了半双工通信的弊端。它最大的特点是：**服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。**相较于`HTTP`协议，`WebSocket`支持双向通信，更加灵活和高效，可扩展性更好。

## 17. HTTP常见的请求方法

| GET | 请求指定的页面信息 |
| --- | --- |
| HEAD | 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| POST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。 |
| PUT | 从客户端向服务器传送的数据取代指定的文档的内容。 |
| DELETE | 请求服务器删除指定的页面。 |
| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 |
| OPTIONS | 允许客户端查看服务器的性能。 |
| TRACE | 回显服务器收到的请求，主要用于测试或诊断。 |
| PATCH | 是对 PUT方法的补充，用来对已知资源进行局部更新 。 |