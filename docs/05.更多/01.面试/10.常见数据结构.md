---
title: 常见数据结构
date: 2023-09-04 17:56:30
permalink: /pages/a79887/
categories:
  - 更多
  - 面试
tags:
  - 
author: 
  name: cyy
  link: https://github.com/Bunny0927
---

## 数组和链表

数组是一种连续线性数据结构，由同一种相同类型的元素组成，通过数组下标访问。

链表是一种非连续的数据结构，由节点组成，每个节点包含数据和指向下一个节点的指针。

数组的查找较快，删除和插入较慢；链表的查找较慢，删除和插入较快。

## 栈和队列

栈是遵循后进先出（LIFO）原则，常见应用场景为函数调用、表达式求值、浏览器前进后退功能。

队列遵循先进先出（FIFO）原则，常见应用场景为任务调度、消息传递、缓存管理。

## 哈希表

哈希表是一种基于哈希函数实现的数据结构，用于关联和存储键值对。哈希函数将输入映射到唯一的索引，通过索引可以快速访问和插入数据。解决哈希碰撞的常见方法由链地址法、开放地址法。

用于存储数据，提高后续访问速度，常见应用场景有缓存系统、数据库索引、路由表等。

## 树

树是一种非线性的数据结构，由节点和边组成。

二叉树是每个节点最多有两个子节点的树结构。

树的遍历方式包括前序遍历（根-左-右）、中序遍历（左-根-右）和后序遍历（左-右-根），它们在不同的应用场景中有不同的用途。

二叉搜索树是一种特殊的二叉树，左子节点的值小于父节点，右子节点的值大于父节点，左右子树也是二叉搜索树。

平衡二叉树（AVL树）是一种绝对平衡的二叉搜索树，它具有以下特点：

- 他的左右子树都是AVL树；
- 左右子树高度差(又称平衡因子)的绝对值不超过1；
- 如果一颗二叉搜索树是高度平衡的，他就是AVL树，如果他有n个节点，其高度可保持在O(log2n)，搜索时间复杂度O(log2n)。

[红黑树](https://blog.csdn.net/cy973071263/article/details/122543826)是一种自平衡的二叉搜索树。红黑树常用于实现关联数组和有序集合，如C++的STL中的map和set。它具有以下特点：

- 每个节点都有颜色（红色或黑色）；
- 根节点和叶子节点是黑色的，红色节点的子节点都是黑色的；
- 从任意节点到其每个叶子节点的路径都包含相同数量的黑色节点；
- 红黑树的自平衡性质保证了其插入、删除和查找操作的时间复杂度都是对数级别的。相比与平衡二叉树，牺牲了部分平衡，但是减少了数据插入和删除的旋转次数。

B树是一种自平衡的搜索树，广泛应用于文件系统和数据库中。B树具有以下特点：

- 每个节点可以有多个子节点。
- 每个节点可以存储多个键值对，按键的顺序排列。
- 所有叶子节点在同一层级。
- 通过调整节点的分裂和合并，保持树的平衡性。

堆是一种特殊的树结构，用于高效地找到最值。

堆可以分为最大堆（Max Heap）和最小堆（Min Heap）两种类型，具有以下性质：

- 在最大堆中，每个节点的值都大于或等于其子节点的值。
- 在最小堆中，每个节点的值都小于或等于其子节点的值。
- 堆常用于优先队列和排序算法中。

## 图

图是由节点和边组成的非线性数据结构，用于表示对象之间的关系。

分类：

- 有向图和无向图：有向图中的边具有方向，无向图中的边没有方向。无权图和带权图：每条边是否有一个关联的权重。

图的表示方法：

- 邻接矩阵：邻接矩阵是一个二维矩阵，其中行和列分别表示图中的节点，矩阵中的元素表示节点之间的边。
- 邻接表：邻接表是一种使用链表或数组的数据结构，用于表示节点和与之相邻的边。

图算法：

- 深度优先搜索（DFS），DFS通过递归或栈实现
- 广度优先搜索（BFS），BFS通过队列实现
- 最短路径算法
    - Dijkstra算法：解决单源最短路径问题
        - 步骤
            - 初始化：创建一个距离数组dist[]，用于保存起始节点到每个节点的最短距离。将起始节点的距离设置为0，其他节点的距离设置为无穷大。创建一个集合visited[]，用于记录已经找到最短路径的节点。
            - 迭代过程：重复以下步骤直到所有节点都被访问：
                - 从未访问的节点中选择距离最小的节点u，将其标记为visited[]。
                - 遍历节点u的所有邻居节点v，计算起始节点到v的距离。如果通过节点u到达节点v的距离比当前记录的距离更短，则更新距离数组dist[]中的值。
            - 当所有节点都被访问后，dist[]数组中保存了起始节点到每个节点的最短距离。
    - Floyd算法：解决所有节点对之间的最短路径问题
        - 步骤
            - 初始化：创建一个大小为n×n的距离矩阵dist[][]，其中n是图中节点的数量。将距离矩阵初始化为节点之间的直接距离，如果两个节点之间没有直接边，则距离设置为无穷大。同时，设置一个大小为n×n的中间节点矩阵next[][]，用于记录最短路径中的下一个节点。
            - 迭代过程：对于每对节点i和j，尝试通过中间节点k来改进i到j的最短路径。遍历所有的i、j和k，执行以下步骤：
                - 如果通过节点k可以获得更短的路径（dist[i][k] + dist[k][j] < dist[i][j]），则更新距离矩阵dist[i][j]和中间节点矩阵next[i][j]的值。
            - 当所有节点的对之间的最短路径都计算完毕后，dist[][]矩阵保存了所有节点对之间的最短距离，next[][]矩阵记录了最短路径中的下一个节点。
- 最小生成树算法
    - Prim算法：从一个起始节点开始，逐步添加与当前树连接的最小权重边，直到所有节点都被连接。
    - Kruskal算法：过按权重递增的顺序逐步添加边，直到所有节点都被连接。

图的常见应用：包括社交网络分析、路线规划和网络拓扑分析。